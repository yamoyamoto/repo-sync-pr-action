# action.yml
name: "Cross-Repository Pull Request"
description: "Syncs commits from a source repository and creates/updates a pull request in a target repository, preserving full commit history."
author: "yamoyamoto"

inputs:
  target_repo:
    description: 'The target repository to create the pull request in (e.g., "owner/repo").'
    required: true
  token:
    description: "A GitHub token with repo and workflow scopes for the target repository."
    required: true
  skip_checkout:
    description: "Skip internal checkout and use current working directory."
    required: false
    default: "false"
  push_tags:
    description: "Also push all tags to the target repository."
    required: false
    default: "false"
  pr_base_branch:
    description: "The base branch for the pull request in the target repository."
    required: false
    default: "main"
  pr_title:
    description: "The title of the pull request."
    required: false
    default: "Sync: Update from source repository"
  pr_body:
    description: "The body of the pull request."
    required: false
    default: "This PR is auto-generated and contains the latest commits from the source repository."
  pr_assignee:
    description: "The assignee for the pull request."
    required: false
  pr_label:
    description: "Labels to add to the pull request (comma-separated)."
    required: false

runs:
  using: "composite"
  steps:
    - name: Checkout source
      if: ${{ inputs.skip_checkout != 'true' }}
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        persist-credentials: false
        fetch-tags: true

    - name: Setup Git
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        GH_HOST: github.com
      run: |
        set -euo pipefail
        # Detect token type via API: PAT/GITHUB_TOKEN can call /user; App installation token cannot
        if gh api user >/dev/null 2>&1; then
          login=$(gh api user -q .login)
          id=$(gh api user -q .id)
          name=$(gh api user -q .name)
          if [ -z "$name" ] || [ "$name" = "null" ]; then
            name="$login"
          fi
          email="${id}+${login}@users.noreply.github.com"
        else
          # Installation token path: try to resolve app_slug from /installation; fallback to github-actions[bot]
          app_slug=$(gh api /installation -q .app_slug 2>/dev/null || true)
          if [ -n "${app_slug:-}" ] && [ "${app_slug}" != "null" ]; then
            login="${app_slug}[bot]"
            id=$(gh api "users/${login}" -q .id 2>/dev/null || echo "")
            name="$login"
            if [ -n "$id" ]; then
              email="${id}+${login}@users.noreply.github.com"
            else
              # Unknown id; still use noreply without id
              email="${login}@users.noreply.github.com"
            fi
          else
            echo "Failed to resolve bot identity: /user not accessible and /installation returned no app_slug" >&2
            exit 1
          fi
        fi
        git config user.name "$name"
        git config user.email "$email"

    - name: Push to Target Repository
      shell: bash
      env:
        PR_BASE_BRANCH: ${{ inputs.pr_base_branch }}
      run: |
        set -euo pipefail
        SOURCE_BRANCH="${SOURCE_BRANCH:-$(git rev-parse --abbrev-ref HEAD)}"
        SYNC_BRANCH="sync/source-${SOURCE_BRANCH}"
        echo "::set-output name=sync_branch::${SYNC_BRANCH}"

        git remote add target "https://x-access-token:${{ inputs.token }}@github.com/${{ inputs.target_repo }}.git" 2>/dev/null || true
        git fetch target "${PR_BASE_BRANCH}:refs/remotes/target/${PR_BASE_BRANCH}" --prune --tags --force

        # Establish a common ancestor with base if histories are unrelated
        MERGE_BASE=$(git merge-base HEAD "refs/remotes/target/${PR_BASE_BRANCH}" || true)
        if [ -z "${MERGE_BASE}" ]; then
          git merge --no-edit --allow-unrelated-histories -s ours "refs/remotes/target/${PR_BASE_BRANCH}" -m "chore: establish common history with ${PR_BASE_BRANCH}"
        fi

        git push target "${SOURCE_BRANCH}:${SYNC_BRANCH}" --force
        if [ "${{ inputs.push_tags }}" = "true" ]; then
          git push target --tags
        fi
      id: push

    - name: Create or Update Pull Request
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        GH_HOST: github.com
        TARGET_REPO: ${{ inputs.target_repo }}
        PR_TITLE: ${{ inputs.pr_title }}
        PR_BODY: ${{ inputs.pr_body }}
        PR_BASE_BRANCH: ${{ inputs.pr_base_branch }}
        PR_ASSIGNEE: ${{ inputs.pr_assignee }}
        PR_LABEL: ${{ inputs.pr_label }}
        SYNC_BRANCH: ${{ steps.push.outputs.sync_branch }}
      run: |
        set -euo pipefail

        # Ensure a usable git context for gh (some versions expect an 'origin' remote)
        if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
          git init .
        fi
        git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${TARGET_REPO}.git" 2>/dev/null || \
          git remote add origin "https://x-access-token:${GH_TOKEN}@github.com/${TARGET_REPO}.git"

        TARGET_OWNER="${TARGET_REPO%%/*}"
        HEAD_BRANCH="${SYNC_BRANCH}"

        # Skip if no diff and no existing PR
        AHEAD_BY=$(gh api -X GET "repos/${TARGET_REPO}/compare/${PR_BASE_BRANCH}...${HEAD_BRANCH}" -q .ahead_by || echo "")
        if [ "${AHEAD_BY:-0}" = "0" ]; then
          PR_NUMBER=$(gh pr list --repo "$TARGET_REPO" --head "$HEAD_BRANCH" --json number --jq '.[0].number' || true)
          if [ -z "${PR_NUMBER:-}" ]; then
            echo "No diff between ${PR_BASE_BRANCH} and ${HEAD_BRANCH}. Skipping PR creation."
            exit 0
          fi
        fi

        # Build args for creation (supports --head/--label/--assignee)
        declare -a pr_create_args
        pr_create_args+=(--base "$PR_BASE_BRANCH")
        pr_create_args+=(--head "$HEAD_BRANCH")
        pr_create_args+=(--title "$PR_TITLE")
        pr_create_args+=(--body "$PR_BODY")
        if [ -n "$PR_ASSIGNEE" ]; then
          pr_create_args+=(--assignee "$PR_ASSIGNEE")
        fi
        if [ -n "$PR_LABEL" ]; then
          pr_create_args+=(--label "$PR_LABEL")
        fi

        # Build args for edit (no --head; labels/assignees use add-*)
        declare -a pr_edit_args
        pr_edit_args+=(--title "$PR_TITLE")
        pr_edit_args+=(--body "$PR_BODY")
        if [ -n "$PR_BASE_BRANCH" ]; then
          pr_edit_args+=(--base "$PR_BASE_BRANCH")
        fi
        if [ -n "$PR_ASSIGNEE" ]; then
          pr_edit_args+=(--add-assignee "$PR_ASSIGNEE")
        fi
        if [ -n "$PR_LABEL" ]; then
          pr_edit_args+=(--add-label "$PR_LABEL")
        fi

        # Try create; on failure, resolve PR by head and edit it
        if ! gh pr create --repo "$TARGET_REPO" "${pr_create_args[@]}"; then
          PR_NUMBER=$(gh pr list --repo "$TARGET_REPO" --head "$HEAD_BRANCH" --json number --jq '.[0].number' || true)
          if [ -z "${PR_NUMBER:-}" ]; then
            echo "No existing PR found for head $HEAD_BRANCH; aborting edit." >&2
            exit 1
          fi
          gh pr edit --repo "$TARGET_REPO" "$PR_NUMBER" "${pr_edit_args[@]}"
        fi
